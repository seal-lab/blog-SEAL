---
layout: post
title: "Flying ESP32 ğŸš€!"
img: flying_ESP32_12_2020/flying_ESP32_12_2020.png # Add image post (optional)
date: 2020-12-16 08:00:00 +0100
description: Premier vol avec Ardupilot sur ESP32
categories: [Recherche]
tags: [Research, Aerial robot, Education]
--- 


# Premier envol de notre drone avec Ardupilot sur ESP32 ğŸ‘Œ

Pour notre projet d'**architecture commune** entre tous nos robots ğŸ¤– nous nous sommes basÃ©s sur le programme **[ArduPilot](https://ardupilot.org/ "Liens vers le projet ArduPilot")**. Il s'agit d'un projet **open-source** regroupant de nombreux **experts** du domaine des **drones lÃ©gers** et des **modÃ©listes** du monde entier ğŸŒ.

{:refdef: style="text-align: center;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/ardupilot_logo.png){: style="width:70%;"}<br/>
<!-- ** ** -->
{: refdef}

> ArduPilot est un **autopilote** qui propose des briques d'autonomie complexes pour contrÃ´ler ğŸ•¹ï¸ des drones multi-hÃ©lices ğŸš, des avions âœˆï¸, des voitures ğŸš— ou des bateaux â›µ, ainsi que des sous-marins ğŸ³!

Nous avons entrepris de porter ce programme ğŸ’» sur un **nouveau micro-contrÃ´leur** : l'**ESP32**. Celui-ci est trÃ¨s utilisÃ© pour l'IoT et bÃ©nÃ©ficie d'une large communautÃ©. ArduPilot est en gÃ©nÃ©ral **uniquement disponible** sur des micro-contrÃ´leurs **STM32** Ã  **architecture ARM** qui nÃ©cessitent des cartes Ã©lectroniques complexes et souvent coÃ»teuses.


{:refdef: style="text-align: center;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/ESP32_IMU_PCB.jpg){: style="width:49%;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/ESP32_CM.jpg){: style="width:49%;"}<br/>
**L'ESP32, notre centrale d'attitude et la carte que nous avons designÃ©e pour aller sur tous nos robots**<br/> 
(avant et aprÃ¨s assemblage)
{: refdef}


> Ce portage facilite donc la construction d'un robot et rÃ©duit les coÃ»ts pour les briques de base de nos robots multi-milieux. Mais il a amenÃ© de nombreux challenges Ã  rÃ©soudre ! 

En effet, les **architectures *hardware*** entre l'ESP32 et les STM32 sont trÃ¨s **diffÃ©rentes** et ne disposent pas des mÃªmes **fonctionnalitÃ©s**. Par exemple, l'ESP32 a introduit le **multi-cÅ“urs** dans le monde des micro-contrÃ´leurs. Or si on veut l'utiliser pour contrÃ´ler des vÃ©hicules, la **maÃ®trise fine du temps** â³ devient **primordiale** et il faut donc parfaitement gÃ©rer la **parallÃ©lisation** des tÃ¢ches.
 
> Autre problÃ¨me de taille : venant de l'IoT ğŸŒ l'ESP32 n'est Ã  l'origine pas taillÃ©e pour de la performance ğŸƒâ€â™‚ï¸â±ï¸. 

Quelques **dÃ©fauts** sont donc prÃ©sents pour notre application tel que le **module I2C *hardware*** qui est trÃ¨s **lent** ğŸŒ ou le fait qu'il n'y ait pas de **canal DMA** pour copier directement en mÃ©moire les donnÃ©es arrivant des diffÃ©rents capteurs. Dans notre cas, la problÃ©matique de l'I2C est particuliÃ¨rement importante ğŸ§, car c'est le **bus** qui nous permet de communiquer avec notre **centrale d'attitude**. Ce capteur est **indispensable** pour faire les **asservissements** les plus basiques du vÃ©hicule, tels que l'asservissement en assiette, en cap, en accÃ©lÃ©ration ou encore en hauteur. 

> Pour tous nos autres robots, ce n'Ã©tait pas rÃ©ellement un problÃ¨me, mais pour un drone multi-rotors, la vitesse de rafraichissement des donnÃ©es en provenance des capteurs est capitale pour permettre le maintien en l'air ğŸ¦….


{:refdef: style="text-align: center;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/kraken.jpg){: style="width:32%;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/ryujin.png){: style="width:32%;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/mabouya.jpg){: style="width:32%;"}<br/>
**Tout fonctionne pour Kraken, notre catamaran, Ryujin, notre sous-marin et Mabouya, notre voiture, mais Kiwi, notre drone volant, ne peut pas dÃ©coller ğŸ˜±!**
{: refdef}

Quant Ã  l'absence de DMA, cela impose de prendre plus de **temps CPU** pour certains bus (ğŸ˜… heureusement on a deux cÅ“urs ğŸ’).

Mis Ã  part le problÃ¨me de l'I2C, ces diffÃ©rentes **contraintes** ont Ã©tÃ© relevÃ©es par les **Ã©tudiants du laboratoire**, notamment avec le travail de Charles Villard, qui y est maintenant **[doctorant]({% post_url 2020-11-01-bienvenue_charles %})**. Ces **travaux** leur ont permis de **co-publier** un **[article scientifique]({% post_url 2020-05-05-copublications_etudiants_isprs %})** ğŸ“ƒğŸ“ sur le sujet. 

> Quant au **dernier point bloquant** pour que notre projet puisse fonctionner sur des **drones volants**, ce sont les Ã©tudiants d'un **groupe PFE** (*Projet de Fin d'Ã‰tudes*) de la **majeure GISTRE**, spÃ©cialisÃ©e sur les **systÃ¨mes embarquÃ©s**, qui se sont penchÃ©s dessus.    


Le groupe est composÃ© de LoÃ¯c Bellonnet-Mottet, Thomas Lupin et Vincent Parizet. En premiÃ¨re Ã©tape, ils ont mis en place une **procÃ©dure de test** âš–ï¸ avec notre centrale d'attitude pour **mesurer les performances** initiales et Ã  venir. Puis ils ont ***profilÃ©*** ğŸ” le code afin d'identifier les diffÃ©rents goulots d'Ã©tranglement ralentissant l'Ã©chantillonnage des donnÃ©es. 

> Ils ont pu voir, entre autres, une utilisation extensive de listes chaÃ®nÃ©es, une gestion non optimale des allocations mÃ©moires dynamiques (Ã  Ã©viter au maximum en embarquÃ©) et de nombreuses interruptions dues Ã  la maniÃ¨re d'utiliser les buffers *hardware* du module I2C. 

De plus, en Ã©tudiant le comportement *hardware* en lui-mÃªme, ils ont constatÃ© quelques dÃ©fauts empÃªchant une communication I2C fiable, rapide et stable. 

> Ce dernier point, particuliÃ¨rement, a orientÃ© le projet vers une solution *software*.  

Ils ont ensuite explorÃ©, implÃ©mentÃ© et testÃ© âš—ï¸ **plusieurs solutions** en s'inspirant des *drivers* de diffÃ©rents OS *open-source* supportant l'ESP32 dont ils ont comparÃ©s les performances. Forts des implÃ©mentations des diffÃ©rents **OS temps rÃ©els** disponibles sur ESP32 (tels RIOT OS), ils ont rassemblÃ© les **optimisations** des diffÃ©rents projets afin d'obtenir un *driver* I2C performant capable de lire les donnÃ©es de la centrale.

  
> La vitesse mesurÃ©e par le banc de test a significativement augmentÃ©e ğŸ˜¯ : on a ainsi pu atteindre et dÃ©passer les 400 Hz de lecture, nÃ©cessaires au vol d'un drone ! 


Sauf que, en passant par une solution *software* plutÃ´t que *hardware*, le protocole se retrouve directement gÃ©rÃ© par le **CPU**. Il fallait donc **vÃ©rifier** que cette implÃ©mentation n'Ã©tait pas **trop gourmande** en **ressources** et permettait bien Ã  Ardupilot de s'exÃ©cuter sans que cela **impacte** les autres tÃ¢ches ğŸ¥ºğŸ¤...
  

{:refdef: style="text-align: center;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/under_test_pilote.jpg){: style="width:49%;"}
![image]({{site.baseurl}}/assets/img/flying_ESP32_12_2020/under_test_drone.jpg){: style="width:49%;"}<br/>
**Aujourd'hui, c'Ã©tait l'heure du verdict avec le test sur la plateforme ğŸ¥!**
{: refdef}


Charles a donc ajoutÃ© leur implÃ©mentation dans le projet ArduPilot sur ESP32 et a rÃ©alisÃ© les **essais de vol** Ã  l'*Under*. Voici la vidÃ©o du rÃ©sultat, sans rÃ©glage des PIDs mais avec un peu de filtrage de donnÃ©es :


<center>
<iframe src="https://www.youtube.com/embed/66Vtt2hcc1Q" style="width: 90%; min-height:450px; border:none;overflow:hidden" scrolling="no" frameborder="0" allowTransparency="true" allowFullScreen="true" allow="accelerometer; gyroscope;"></iframe>
<br/><strong>Tout premier vol : sucess ğŸ¥³ !!!</strong> 
</center>

<br/>

Ce premier **vol symbolique** montre la capacitÃ© de l'ESP32 Ã  tenir les contraintes des drones volants et la faisabilitÃ© du projet ! Et au final, la comparaison de la charge CPU avec et sans l'implÃ©mentation montre que le passage Ã  un *driver* *software* est plutÃ´t nÃ©gligeable sur notre utilisation ğŸ¤©. Maintenant il ne reste plus qu'Ã  **rÃ©gler les configurations classiques** d'un drone pour qu'il puisse rÃ©pondre Ã  nos besoins de mission : bref, de la routine !

> Bravo aux Ã©tudiants impliquÃ©s pour la qualitÃ© de leur travail ğŸ‘ğŸ‘ !

Ce projet de portage sur ESP32 est en cours de peaufinage : l'objectif est de pouvoir contribuer sur la **branche principale** du projet ArduPilot et donc de faire profiter la **communautÃ©** des avantages et de la simplicitÃ© d'utilisation de l'ESP32. 

> N'hÃ©sitez pas Ã  venir **contribuer** si Ã§a vous intÃ©resse ! 


Ã€ suivre donc ğŸ˜‰...







